# 퀵 정렬(Quick Sort)

> 2024.07.17 수요일 수업😎

주먹밥쿵야 반가워요~ 오늘은 함께 퀵정렬에 대해 알아볼게요! 저는 반모할게요~!

🤔 **주먹밥쿵야:** 네에ㅎㅎ 퀵 정렬의 특징을 알려주세요!

이름에서 알 수 있듯이 매우 빠른 수행 속도를 자랑하는 정렬 방법이야.


😯 **주먹밥쿵야:** 퀵퀵.. 퀵 정렬의 과정을 설명해주세요.

먼저 리스트 안에 있는 한 요소를 선택하고, (그 요소를 피벗이라고 해!)
피벗을 기준으로 작은 애들은 왼쪽으로, 큰 애들은 오른쪽으로 옮겨지는 거야.
그리고나서 피벗을 제외한 왼쪽 애들 무리랑 오른쪽 애들 무리를 다 정렬하는 과정을 거쳐.
그 무리 애들 중에 또 피벗을 정하고, 반복하는 거야.
```
- 퀵 정렬의 3단계

- 1단계 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 = 피벗보다 작은 요소들, 오른쪽 = 피벗보다 큰 요소들)로 분할한다.
- 2단계 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.
- 3단계 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
```

😳 **주먹밥쿵야:** 피벗이 포인트같네요. 어떤 걸 피벗으로 선택해야 하나요?

맞아~! 퀵정렬에서는 피벗이 포인트라고 기억하면 좋을 것 같네. 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있어. 왼쪽, 가운데, 오른쪽 피벗 선택방법 등이 있는데, 각각 방법이 다르니 자세한 과정은 아래 블로그를 참고해봐!
https://velog.io/@wndudrla1011/interview-algorithm-sort-quick
```
- 대표적인 피벗 선정 방법

- 첫번째 값이나 마지막 값을 피벗으로 선정한다.
- 첫번째 값, 가운데 값, 마지막 값 중에 중간값을 피벗으로 선정한다.(Median of Three)
- 무작위 값을 피벗으로 선정한다.
```

🤔 **주먹밥쿵야:** 피벗 선정에 따라 시간복잡도가 어떻게 되나요?

선정한 피벗이 하필! 제일 작거나 제일 클 때 최악의 시간복잡도 결과가 나와. O(n²)가 되는 것이지! 평균 O(NlogN)이야. 유의할 점은 이미 정렬된 상태에서 퀵 정렬을 사용하면 비효율적이라는 것을 기억해. 그럴 때는 성능이 급격하게 떨어지거든.

😳 **주먹밥쿵야:** 그렇군요. 다른 O(NlogN) 알고리즘에 비해 대체적으로 속도가 빠른 퀵 정렬이겠네요. 다른 장점도 있을까요?

퀵 정렬은 추가적인 별도의 메모리를 필요로 하지 않고, 재귀호출 Stack 프레임에 의한 공간 복잡도는 logN으로 메모리를 적게 소비한다는 다른 장점이 있어. 근데 재귀를 사용하기 때문에 재귀를 사용하지 못하는 환경일 경우 구현이 복잡해진다는 단점이 있기도 해.