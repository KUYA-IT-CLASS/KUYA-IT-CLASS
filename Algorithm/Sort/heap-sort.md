# 힙 정렬(Heap Sort)

> 2024.07.16 화요일 수업😎


이번 교시에는 **힙 정렬(Heap Sort)** 에 대해 알아보려고 해요~ 쿵야 학생은 `힙(Heap)`에 대해 들어본 적이 있나요?

- **🍙 주먹밥쿵야:** 음... Java를 배우면서 들어본 것 같은데 자세히는 모르겠어요!!

**힙(Heap)** 은 자료구조의 일종으로 부모 노드가 최대 2개 이내의 자식을 가지는 `이진 트리(Binary Tree)` 중에서도 마지막 레벨 이전까지의 모든 노드가 빈 공간 없이 가득찬 형태의 `완전 이진 트리(Complete Binary Tree)`의 형태를 가졌어요! 정렬 방식에 따라 부모 노드가 자식 노드의 값 보다 더 크면 '최대 힙', 반대의 경우 '최소 힙'이라고 불려요. 그런데 이 힙(Heap)은 조금 특이해요. 예를 들어 최대 힙은 부모의 값이 자식의 값 보다 크다는 특징이 있지만 현재 부모의 키 값보다 자식의 키 값이 작다면 부모의 형제 노드의 키 값 보다 더 큰 값이라도 자식으로 들어갈 수 있다는 특징이 있어요. 

```
// 힙(Heap)

          [8]
        ╱    ╲
     [5]       [2]   
    ╱  ╲     ╱ 
  [4]   [2] [1]          // [4]는 부모 보단 작지만, 부모의 형제 [2] 보다는 클 수 있다!
```

- **🍙 주먹밥쿵야:** 최대 힙을 사용하면 대략적으로 큰 값을 찾기가 좋을 것 같아요!

맞아요. 또한 힙은 `우선 순위 큐(PriorityQueue)`를 구현하는데 사용되는데, 이건 Java에도 존재하는 자료구조니 나중에 한번 사용해 보아요! 자, 그럼 힙 정렬에 대해서 알려줄게요. 아! 참고로 힙 정렬을 구현할 때에는 1차원 배열을 사용해요. 완전 이진 트리는 아까 말했듯이 중간에 빈 공간이 없이 이루어져있어요. 그래서 그냥 순서대로 값을 채우면 되어서 1차원 배열로 구현하는거지요. 

- **🍙 주먹밥쿵야:** 아! 그럼 아까 그려주신 트리는 1차원 배열로 표현하면 `[8,5,2,4,2,1]`인가요?!

맞아요~ 위에서부터 왼쪽 → 오른쪽 순으로 차례대로 작성하면 된답니다. 자 이제 힙 정렬을 알려줄게요. 주어진 배열 `[6, 5, 3, 1, 8, 7, 2, 4]`을 가지고 내림차순 정렬을 해보려고 해요. 

- **🍙 주먹밥쿵야:** 어려울 것 같아요..ㅠㅠ

어렵지 않으니 걱정말고 따라와요! 힙 정렬은 크게 두가지 과정이 있다고 생각하면 될것 같아요. 우선 정렬을 위해서는 `최대 힙` 또는 `최소 힙`을 구성해야 하는데요. 우리는 내림차순 정렬을 할거니까 `최대 힙`을 구성하면 된답니다. 

- **🍙 주먹밥쿵야:** 오름차순 정렬에는 최소 힙을 만들면 되나요?

딩동댕~! 하지만 우리는 내림차순 정렬을 할거니까 최대 힙을 만들건데, 최대 힙은 아까 말했듯이 부모 키 값 > 자식 키 값 이면서, 최상단(루트) 노드의 키 값이 가장 큰 특징을 가지고 있어요. 주어진 배열 `[6, 5, 3, 1, 8, 7, 2, 4]`을 최대 힙으로 만들면 `[8, 6, 7, 4, 5, 3, 2, 1]` 형태가 된답니다.

```
// 최대 힙(Maximun Heap)
// [8, 6, 7, 4, 5, 3, 2, 1]

          [8]
        ╱    ╲
     [6]       [7]   
    ╱  ╲     ╱  ╲
  [4]   [5] [3]   [2]
 ╱
[1]
```
벌써 어느정도 정렬이 된 것 같아 보이지만, 자세히 들여다보면 형제 노드끼리 정렬이 되어있지 않은 것이 보이나요?

- **🍙 주먹밥 쿵야:** 앗, 그러네요? 정렬이 되고 나면 `[8, 7, 6...]` 이어야 하는데 지금은 `[8, 6, 7...]` 로 시작해요.

힙 정렬을 하는 방법을 간단하게 설명하자면, 
```
최대 힙을 만든다. <────────────────────────────┐
 │                                                         │
 └─> 첫번째 값을 정렬되지 않은 값 중 마지막 노드의 값과 교체 ──────┘
```

최대 힙을 구성한다는 것은 힙에서 존재하는 값들 중 최댓값이 최상단(루트) 노드에 존재한다는 것을 의미하잖아요? 그래서 최대 힙을 구성하여 정렬되지 않은 값 중 가장 큰 값을 찾아 최상단 노드에 옮기고, 그 값을 가장 뒤에서 부터 하나씩 채우는 거에요. 이 때, 뒤에 채운 값은 '정렬된 값'이고, 나머지 값은 '정렬 되지 않은 값'이라고 생각하면 될 것 같아요. 

말로만 하면 어려우니까 예시를 함께 준비해보았어요. 아래 표를 참고하여 정렬 과정을 확인해볼까요? <br/>
(참고로 `코드` 표시가 된 값은 정렬된 값이랍니다.)

| [ 8 ] | [ 6 ] | [ 7 ] | [ 4 ] | [ 5 ] | [ 3 ] | [ 2 ] | [ 1 ] |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| ***8*** | 6 | 7 | 4 | 5 | 3 | 2 | ***1*** |
| 1 | 6 | 7 | 4 | 5 | 3 | 2 | `8` |
| ***1*** | 6 | ***7*** | 4 | 5 | 3 | 2 | `8` |
| 7 | 6 | **1** | 4 | 5 | ***3*** | 2 | `8` |
| ***7*** | 6 | 3 | 4 | 5 | 1 | ***2*** | `8` |
| 2 | 6 | 3 | 4 | 5 | 1 | `7` | `8` |
| ***2*** | ***6*** | 3 | 4 | 5 | 1 | `7` | `8` |
| 6 | ***2*** | 3 | 4 | ***5*** | 1 | `7` | `8` |
| ***6*** | 5 | 3 | 4 | 2 | ***1*** | `7` | `8` |
| 1 | 5 | 3 | 4 | 2 | `6` | `7` | `8` |
| ***1*** | ***5*** | 3 | 4 | 2 | `6` | `7` | `8` |
| 5 | **1** | 3 | ***4*** | 2 | `6` | `7` | `8` |
| ***5*** | 4 | 3 | 1 | ***2*** | `6` | `7` | `8` |
| 2 | 4 | 3 | 1 | `5` | `6` | `7` | `8` |
| ***2*** | ***4*** | 3 | 1 | `5` | `6` | `7` | `8` |
| ***4*** | 2 | 3 | ***1*** | `5` | `6` | `7` | `8` |
| 1 | 2 | 3 | `4` | `5` | `6` | `7` | `8` |
| ***1*** | 2 | ***3*** | `4` | `5` | `6` | `7` | `8` |
| ***3*** | 2 | ***1*** | `4` | `5` | `6` | `7` | `8` |
| 1 | 2 | `3` | `4` | `5` | `6` | `7` | `8` |
| ***1*** | ***2*** | `3` | `4` | `5` | `6` | `7` | `8` |
| ***2*** | ***1*** | `3` | `4` | `5` | `6` | `7` | `8` |
| 1 | `2` | `3` | `4` | `5` | `6` | `7` | `8` |
| ***1*** | `2` | `3` | `4` | `5` | `6` | `7` | `8` |
| `1` | `2` | `3` | `4` | `5` | `6` | `7` | `8` |

참고로 힙 정렬은 최고, 평균, 최악 모두 `NlogN`의 시간 복잡도를 가지고 있어요. 이는 퀵 정렬과 동일하지만 실제 코드로 실행시키면 퀵 정렬이 실행 속도는 더 빠르다고 해요. 오늘의 수업은 여기서 마치도록 할게요~! 

<br/>

## 정리 노트
### 완전 이진 트리(Complete Binary Tree) 란?
> 최상위(Root) 노드부터 마지막 레벨 이전까지 모든 노드가 중간에 빈 공간이 없이 가득찬 트리 (왼쪽 → 오른쪽 순)
- 이진 트리 이므로 부모가 가질 수 있는 자식의 노드는 최대 `2`개
- 완전 이진 트리는 **1차원 배열**로 구현할 수 있음

### 힙(Heap) 이란?
> 완전 이진 트리(Complete Binary Tree)의 일종으로 최댓값 또는 최솟값을 쉽게 추출할 수 있는 자료구조
- `우선 순위 큐(PriorityQueue)`를 위해 만들어진 자료구조
- **정렬 방식**에 따른 종류
  - 최대 힙(maximum heap): 최상위(루트) 노드는 전체 노드 중 최댓값을 가짐
    - 부모 노드의 키 값 > 자식 노드의 키 값 
    - 내림차순 정렬 
  - 최소 힙(minimun heap): 최상위(루트) 노드는 전체 노드 중 최솟값을 가짐
    - 부모 노드의 키 값 < 자식 노드의 키 값
    - 오름차순 정렬
- **1차원 배열**을 이용한 구현 방식 
  - `0`번째 인덱스 부터 순서대로 값을 채움
  - 현재 인덱스가 `i`라고 가정할 때,
    - 부모 노드: `⌊(i-1)/2⌋`
    - 자식 노드: (왼쪽) `2*i+1`, (오른쪽) `2*i+2`
  
### 힙 정렬 (Heap Sort)

> [!Tip]
> 시각화 자료는 [여기](https://www.cs.usfca.edu/~galles/visualization/HeapSort.html)를 참고하세요.

| 최고(Best) | 평균(Average) | 최악(Worst) |   
| :-------: | :----------: | :--------: |   
| `NlogN` |  `NlogN` | `NlogN` |

- 특징
  - 불안정(unstable) : 데이터의 순서를 보장하지 않음
  - 제자리(in-place) : 정렬을 위한 추가 메모리 공간이 필요하지 않음
    
- 정렬 방법 (내림차순 기준)
  - 1.　'정렬되지 않은 값'들의 최대 힙을 구성한다. (=첫번째 인덱스에 가장 큰 값 위치)
  - 2.　첫번째(루트) 노드와 '정렬되지 않은 값'의 마지막 노드 값을 교체한다. (=마지막 노드는 정렬된 값)
  - 3.　정렬된 값을 제외하고, 나머지 노드들 간의 최대 힙을 구성한다.
  - 4.　모든 값이 정렬이 완료될 때 까지 2 ~ 3번을 반복한다.
