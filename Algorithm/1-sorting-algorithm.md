# 정렬 알고리즘

### 선택 정렬

### 삽입 정렬

### 버블정렬
> 24.07.16 화요일 수업😎

안녕하세요~ 이번에는 버블정렬에 대해 이야기해볼거에요~
버블 정렬은 숫자들을 순서대로 정리하는 방법이야~

**🧐주먹밥쿵야:** 왜 버블 정렬이라고 불러요?

버블 정렬은 물속에서 거품이 올라오는것처럼 작은 숫자가 천천히 올라가는 모양이라 그렇게 불러

**😝주먹밥쿵야:** 와 재밋겠다!! 어떻게 하는건가요?

숫자들을 일렬로 세운 다음, 옆에 있는 두숫자를 비교해.
왼쪽 숫자가 오른쪽 숫자보다 크면 자리를 바꾸는거야

**🤔주먹밥쿵야:** 그럼, 그 다음에는요?

그걸 계속 반복해, 맨 오른쪽까지 가면 가장 큰 숫자가 맨 오른쪽에 놓이게 돼

**😝주먹밥쿵야:** 진짜 신기해요!!

그리고 나서 다시 처음으로 돌아가 같은 일을 반복해. 이번엔 맨 오른쪽 숫자를 빼고 하는거야.
왜냐면 그 숫자는 이미 제자리에 있으니깐.

**🫥주먹밥쿵야:** 오잉? 그럼 언제까지 반복해요?

모든 숫자가 순서대로 정렬 될때까지 계속해야해. 더 이상 자리를 바꿀 필요가 없을떄 멈추는거지!

**🤨주먹밥쿵야:** 이해했어요! 근데 이 방법이 좋은건가요?

버블 정렬은 이해하기 쉽고 간단해서 좋아. 하지만 숫자가 많아지면 다른 방법들 보다 시간이 오래걸릴수 있어

**😟주먹밥쿵야:** 그렇군요.. 더 자세히 알고싶으면 어떻게 해요?

더 자세히 알고싶다면, 나중에 크면 컴퓨터로 직접 할수있을거야~ 지금은 조금 어려울수있겠지만 나중에 같이  공부해보자!

**😝주먹밥쿵야:** 네 알겠어요!


### 병합정렬
> 24.07.16 화요일 수업😎

오늘은 병합 정렬에 대해 이야기해볼까요?   
병합 정렬은 분할 정복 알고리즘 중 하나로,   
리스트를 계속해서 반으로 나누고, 나눈 부분을 정렬하면서 합치는 방식으로 작동해요.

🤔 **주먹밥쿵야:** 분할 정복 알고리즘이 뭐예요?

분할 정복은 문제를 더 작은 하위 문제로 나누고, 각각을 해결한 다음,   
그 해결책을 결합하여 원래 문제의 해결책을 찾는 방법이에요.   
병합 정렬에서는 리스트를 계속 반으로 나눠서 더 이상 나눌 수 없을 때까지 나눈 후, 다시 합치면서 정렬한답니다.

😯 **주먹밥쿵야:** 어떻게 나눠요? 그리고 언제까지 나누나요?

병합 정렬에서는 리스트를 중간에서 두 부분으로 나눕니다.   
그리고 이 과정을 리스트의 길이가 1이 될 때까지 반복해요.   
길이가 1인 리스트는 이미 정렬된 상태이기 때문에 더 이상 나눌 필요가 없어요.

🤔 **주먹밥쿵야:** 홀수 개수인 리스트는 절반 나누면 어떻게 되는 거예요?

좋은 질문이에요!   
병합 정렬에서 리스트를 반으로 나눌 때 리스트의 길이가 홀수인 경우,   
중간 요소가 속하게 되는 리스트는 구현한 방식에 따라 달라집니다.  
파이썬 코드로 예시를 들어 볼게요.
```
    # 리스트를 중간에서 두 부분으로 나눔
    mid = len(arr) // 2
    # 왼쪽 부분 리스트를 재귀적으로 병합 정렬
    left = merge_sort(arr[:mid])
    # 오른쪽 부분 리스트를 재귀적으로 병합 정렬
    right = merge_sort(arr[mid:])

```
위의 코드는 mid = len(arr) // 2로 인덱스를 계산하고 있죠?   
arr의 길이가 5일 경우 mid는 2이고, 2번째 요소까지 왼쪽 리스트에, 3번째 요소부터 오른쪽 리스트에 속하게 돼요.   
// 연산자는 정수 나눗셈을 수행하여 나머지를 버리기 때문에, 알고리즘을 이렇게 구현할 경우 중간 요소는 항상 오른쪽 리스트에 속하게 된답니다.   

만약 중간 요소가 왼쪽 리스트에 포함되도록 구현하고 싶으면 어떻게 하면 될까요?

🤓 **주먹밥쿵야:** 리스트 중간 인덱스를 계산하는 코드를 `mid = (len(arr) + 1) // 2`로 바꿔요!

정말 훌륭해요~!
그렇게 구현해도 병합 정렬의 원칙과 작동 방식에는 전혀 문제가 없으며,   
결과 역시 올바르게 정렬된 리스트를 얻을 수 있답니다.

😳 **주먹밥쿵야:** 나누는 부분은 이제 알겠어요. 다음은 나눠진 리스트들을 정렬하면서 합치는 거죠? 어떻게 정렬하는 거예요?

두 개의 정렬된 리스트를 병합할 때에는,(아까 내용 기억나죠? 길이가 1인 리스트는 정렬된 리스트예요!)   
새로운 리스트를 만든 뒤 각 리스트의 첫 번째 요소를 비교해서 더 작은 값을 새로운 리스트에 넣습니다.   
이 과정을 두 리스트 모두 요소가 없어질 때까지 반복한답니다.  

예를 들어, [1, 3, 5]와 [2, 4, 6]을 병합하려면,   
1과 2를 비교해서 1을 새로운 리스트에 넣고, 그 다음 3과 2를 비교해서 2를 넣는 식으로 진행합니다.   
새로운 리스트에는 1, 2, 3, 4, 5, 6 순서로 들어가게 되겠죠?   
그렇기 때문에 정렬되면서 새로운 리스트로 병합되는 거예요.

🤔 **주먹밥쿵야:** 정렬 알고리즘은 시간 복잡도가 중요하다고 들었어요. 병합 정렬의 시간 복잡도는 어떻게 되나요?

병합 정렬의 시간 복잡도는 최선, 평균, 최악 어떤 경우든 항상 O(n log n)입니다.   
리스트를 반으로 나누는 데 log n 단계가 필요하고, 각 단계에서 n개의 요소를 병합하기 때문이에요.   
다른 선생님들께 배운 선택 정렬, 버블 정렬의 O(n²)보다는 빠르고 힙 정렬과는 똑같은 시간 복잡도를 가져요.

🧐 **주먹밥쿵야:** 병합 정렬의 장단점에는 어떤 것들이 있나요?

무엇보다 항상 O(n log n)의 시간 복잡도를 가지기 때문에 안정적인 성능을 보인다는 점입니다.   
그리고 안정 정렬이어서 동일한 값의 순서가 유지되어요.   
단점은 추가적인 메모리 공간이 필요하다는 점입니다.   
병합 과정에서 새로운 리스트를 만들어야 하기 때문이에요.

🤓 **주먹밥쿵야:** 더 자세히 공부하고 싶을 때 참고할 자료가 있을까요?

아래 블로그 글을 읽어보세요. 예제 코드를 작성해보는 것도 추천해요!
https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


### 힙정렬

### 퀵정렬
> 24.07.17 수요일 수업😎

주먹밥쿵야 반가워요~ 오늘은 함께 퀵정렬에 대해 알아볼게요! 저는 반모할게요~!

🤔 **주먹밥쿵야:** 네에ㅎㅎ 퀵 정렬의 특징을 알려주세요!

이름에서 알 수 있듯이 매우 빠른 수행 속도를 자랑하는 정렬 방법이야.


😯 **주먹밥쿵야:** 퀵퀵.. 퀵 정렬의 과정을 설명해주세요.

먼저 리스트 안에 있는 한 요소를 선택하고, (그 요소를 피벗이라고 해!)
피벗을 기준으로 작은 애들은 왼쪽으로, 큰 애들은 오른쪽으로 옮겨지는 거야.
그리고나서 피벗을 제외한 왼쪽 애들 무리랑 오른쪽 애들 무리를 다 정렬하는 과정을 거쳐.
그 무리 애들 중에 또 피벗을 정하고, 반복하는 거야.
```
- 퀵 정렬의 3단계

1단계 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 = 피벗보다 작은 요소들, 오른쪽 = 피벗보다 큰 요소들)로 분할한다.
2단계 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.
3단계 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
```

😳 **주먹밥쿵야:** 피벗이 포인트같네요. 어떤 걸 피벗으로 선택해야 하나요?

맞아~! 퀵정렬에서는 피벗이 포인트라고 기억하면 좋을 것 같네. 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있어. 왼쪽, 가운데, 오른쪽 피벗 선택방법 등이 있는데, 각각 방법이 다르니 자세한 과정은 아래 블로그를 참고해봐!
https://velog.io/@wndudrla1011/interview-algorithm-sort-quick
```
대표적인 피벗 선정 방법
- 첫번째 값이나 마지막 값을 피벗으로 선정한다.
- 첫번째 값, 가운데 값, 마지막 값 중에 중간값을 피벗으로 선정한다.(Median of Three)
- 무작위 값을 피벗으로 선정한다.
```

🤔 **주먹밥쿵야:** 피벗 선정에 따라 시간복잡도가 어떻게 되나요?

선정한 피벗이 하필! 제일 작거나 제일 클 때 최악의 시간복잡도 결과가 나와. O(n²)가 되는 것이지! 평균 O(NlogN)이야. 유의할 점은 이미 정렬된 상태에서 퀵 정렬을 사용하면 비효율적이라는 것을 기억해. 그럴 때는 성능이 급격하게 떨어지거든.

😳 **주먹밥쿵야:** 그렇군요. 다른 O(NlogN) 알고리즘에 비해 대체적으로 속도가 빠른 퀵 정렬이겠네요. 다른 장점도 있을까요?

퀵 정렬은 추가적인 별도의 메모리를 필요로 하지 않고, 재귀호출 Stack 프레임에 의한 공간 복잡도는 logN으로 메모리를 적게 소비한다는 다른 장점이 있어. 근데 재귀를 사용하기 때문에 재귀를 사용하지 못하는 환경일 경우 구현이 복잡해진다는 단점이 있기도 해.

### 트리정렬
