# 정렬 알고리즘

### 선택 정렬

### 삽입 정렬

### 버블정렬
> 24.07.16 화요일 수업😎

안녕하세요~ 이번에는 버블정렬에 대해 이야기해볼거에요~
버블 정렬은 숫자들을 순서대로 정리하는 방법이야~

**🧐주먹밥쿵야:** 왜 버블 정렬이라고 불러요?

버블 정렬은 물속에서 거품이 올라오는것처럼 작은 숫자가 천천히 올라가는 모양이라 그렇게 불러

**😝주먹밥쿵야:** 와 재밋겠다!! 어떻게 하는건가요?

숫자들을 일렬로 세운 다음, 옆에 있는 두숫자를 비교해.
왼쪽 숫자가 오른쪽 숫자보다 크면 자리를 바꾸는거야

**🤔주먹밥쿵야:** 그럼, 그 다음에는요?

그걸 계속 반복해, 맨 오른쪽까지 가면 가장 큰 숫자가 맨 오른쪽에 놓이게 돼

**😝주먹밥쿵야:** 진짜 신기해요!!

그리고 나서 다시 처음으로 돌아가 같은 일을 반복해. 이번엔 맨 오른쪽 숫자를 빼고 하는거야.
왜냐면 그 숫자는 이미 제자리에 있으니깐.

**🫥주먹밥쿵야:** 오잉? 그럼 언제까지 반복해요?

모든 숫자가 순서대로 정렬 될때까지 계속해야해. 더 이상 자리를 바꿀 필요가 없을떄 멈추는거지!

**🤨주먹밥쿵야:** 이해했어요! 근데 이 방법이 좋은건가요?

버블 정렬은 이해하기 쉽고 간단해서 좋아. 하지만 숫자가 많아지면 다른 방법들 보다 시간이 오래걸릴수 있어

**😟주먹밥쿵야:** 그렇군요.. 더 자세히 알고싶으면 어떻게 해요?

더 자세히 알고싶다면, 나중에 크면 컴퓨터로 직접 할수있을거야~ 지금은 조금 어려울수있겠지만 나중에 같이  공부해보자!

**😝주먹밥쿵야:** 네 알겠어요!


### 병합정렬
> 24.07.16 화요일 수업😎

오늘은 병합 정렬에 대해 이야기해볼까요?   
병합 정렬은 분할 정복 알고리즘 중 하나로,   
리스트를 계속해서 반으로 나누고, 나눈 부분을 정렬하면서 합치는 방식으로 작동해요.

🤔 **주먹밥쿵야:** 분할 정복 알고리즘이 뭐예요?

분할 정복은 문제를 더 작은 하위 문제로 나누고, 각각을 해결한 다음,   
그 해결책을 결합하여 원래 문제의 해결책을 찾는 방법이에요.   
병합 정렬에서는 리스트를 계속 반으로 나눠서 더 이상 나눌 수 없을 때까지 나눈 후, 다시 합치면서 정렬한답니다.

😯 **주먹밥쿵야:** 어떻게 나눠요? 그리고 언제까지 나누나요?

병합 정렬에서는 리스트를 중간에서 두 부분으로 나눕니다.   
그리고 이 과정을 리스트의 길이가 1이 될 때까지 반복해요.   
길이가 1인 리스트는 이미 정렬된 상태이기 때문에 더 이상 나눌 필요가 없어요.

🤔 **주먹밥쿵야:** 홀수 개수인 리스트는 절반 나누면 어떻게 되는 거예요?

좋은 질문이에요!   
병합 정렬에서 리스트를 반으로 나눌 때 리스트의 길이가 홀수인 경우,   
중간 요소가 속하게 되는 리스트는 구현한 방식에 따라 달라집니다.  
파이썬 코드로 예시를 들어 볼게요.
```
    # 리스트를 중간에서 두 부분으로 나눔
    mid = len(arr) // 2
    # 왼쪽 부분 리스트를 재귀적으로 병합 정렬
    left = merge_sort(arr[:mid])
    # 오른쪽 부분 리스트를 재귀적으로 병합 정렬
    right = merge_sort(arr[mid:])

```
위의 코드는 mid = len(arr) // 2로 인덱스를 계산하고 있죠?   
arr의 길이가 5일 경우 mid는 2이고, 2번째 요소까지 왼쪽 리스트에, 3번째 요소부터 오른쪽 리스트에 속하게 돼요.   
// 연산자는 정수 나눗셈을 수행하여 나머지를 버리기 때문에, 알고리즘을 이렇게 구현할 경우 중간 요소는 항상 오른쪽 리스트에 속하게 된답니다.   

만약 중간 요소가 왼쪽 리스트에 포함되도록 구현하고 싶으면 어떻게 하면 될까요?

🤓 **주먹밥쿵야:** 리스트 중간 인덱스를 계산하는 코드를 `mid = (len(arr) + 1) // 2`로 바꿔요!

정말 훌륭해요~!
그렇게 구현해도 병합 정렬의 원칙과 작동 방식에는 전혀 문제가 없으며,   
결과 역시 올바르게 정렬된 리스트를 얻을 수 있답니다.

😳 **주먹밥쿵야:** 나누는 부분은 이제 알겠어요. 다음은 나눠진 리스트들을 정렬하면서 합치는 거죠? 어떻게 정렬하는 거예요?

두 개의 정렬된 리스트를 병합할 때에는,(아까 내용 기억나죠? 길이가 1인 리스트는 정렬된 리스트예요!)   
새로운 리스트를 만든 뒤 각 리스트의 첫 번째 요소를 비교해서 더 작은 값을 새로운 리스트에 넣습니다.   
이 과정을 두 리스트 모두 요소가 없어질 때까지 반복한답니다.  

예를 들어, [1, 3, 5]와 [2, 4, 6]을 병합하려면,   
1과 2를 비교해서 1을 새로운 리스트에 넣고, 그 다음 3과 2를 비교해서 2를 넣는 식으로 진행합니다.   
새로운 리스트에는 1, 2, 3, 4, 5, 6 순서로 들어가게 되겠죠?   
그렇기 때문에 정렬되면서 새로운 리스트로 병합되는 거예요.

🤔 **주먹밥쿵야:** 정렬 알고리즘은 시간 복잡도가 중요하다고 들었어요. 병합 정렬의 시간 복잡도는 어떻게 되나요?

병합 정렬의 시간 복잡도는 최선, 평균, 최악 어떤 경우든 항상 O(n log n)입니다.   
리스트를 반으로 나누는 데 log n 단계가 필요하고, 각 단계에서 n개의 요소를 병합하기 때문이에요.   
다른 선생님들께 배운 선택 정렬, 버블 정렬의 O(n²)보다는 빠르고 힙 정렬과는 똑같은 시간 복잡도를 가져요.

🧐 **주먹밥쿵야:** 병합 정렬의 장단점에는 어떤 것들이 있나요?

무엇보다 항상 O(n log n)의 시간 복잡도를 가지기 때문에 안정적인 성능을 보인다는 점입니다.   
그리고 안정 정렬이어서 동일한 값의 순서가 유지되어요.   
단점은 추가적인 메모리 공간이 필요하다는 점입니다.   
병합 과정에서 새로운 리스트를 만들어야 하기 때문이에요.

🤓 **주먹밥쿵야:** 더 자세히 공부하고 싶을 때 참고할 자료가 있을까요?

아래 블로그 글을 읽어보세요. 예제 코드를 작성해보는 것도 추천해요!
https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


### 힙정렬

### 퀵정렬

### 트리정렬
